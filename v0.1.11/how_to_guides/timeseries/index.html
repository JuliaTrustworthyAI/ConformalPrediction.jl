<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>How to Conformalize a Time Series Model ¬∑ ConformalPrediction.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://juliatrustworthyai.github.io/ConformalPrediction.jl/how_to_guides/timeseries/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="ConformalPrediction.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ConformalPrediction.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">üè† Home</a></li><li><span class="tocitem">ü´£ Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/">Overview</a></li><li><a class="tocitem" href="../../tutorials/classification/">Classification</a></li><li><a class="tocitem" href="../../tutorials/regression/">Regression</a></li><li><a class="tocitem" href="../../tutorials/plotting/">Visualizations</a></li></ul></li><li><span class="tocitem">ü´° How-To Guides</span><ul><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../mnist/">How to Conformalize a Deep Image Classifier</a></li><li><a class="tocitem" href="../llm/">How to Conformalize a Large Language Model</a></li><li class="is-active"><a class="tocitem" href>How to Conformalize a Time Series Model</a><ul class="internal"><li><a class="tocitem" href="#The-Task-at-Hand"><span>The Task at Hand</span></a></li><li><a class="tocitem" href="#Feature-engineering"><span>Feature engineering</span></a></li><li><a class="tocitem" href="#Train-test-split"><span>Train-test split</span></a></li><li><a class="tocitem" href="#Loading-model-using-MLJ-interface"><span>Loading model using MLJ interface</span></a></li><li><a class="tocitem" href="#Conformal-time-series"><span>Conformal time series</span></a></li><li><a class="tocitem" href="#Results"><span>Results</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li></ul></li><li><span class="tocitem">ü§ì Explanation</span><ul><li><a class="tocitem" href="../../explanation/">Overview</a></li><li><a class="tocitem" href="../../explanation/architecture/">Package Architecture</a></li><li><a class="tocitem" href="../../explanation/finite_sample_correction/">Finite-sample Correction</a></li></ul></li><li><a class="tocitem" href="../../reference/">üßê Reference</a></li><li><a class="tocitem" href="../../contribute/">üõ† Contribute</a></li><li><a class="tocitem" href="../../faq/">‚ùì FAQ</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">ü´° How-To Guides</a></li><li class="is-active"><a href>How to Conformalize a Time Series Model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>How to Conformalize a Time Series Model</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/main/docs/src/how_to_guides/timeseries.md#" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="How-to-Conformalize-a-Time-Series-Model"><a class="docs-heading-anchor" href="#How-to-Conformalize-a-Time-Series-Model">How to Conformalize a Time Series Model</a><a id="How-to-Conformalize-a-Time-Series-Model-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-Conformalize-a-Time-Series-Model" title="Permalink"></a></h1><p>Time series data is prevalent across various domains, such as finance, weather forecasting, energy, and supply chains. However, accurately quantifying uncertainty in time series predictions is often a complex task due to inherent temporal dependencies, non-stationarity, and noise in the data. In this context, Conformal Prediction offers a valuable solution by providing prediction intervals which offer a sound way to quantify uncertainty.</p><p>This how-to guide demonstrates how you can conformalize a time series model using Ensemble Batch Prediction Intervals (EnbPI) (Xu and Xie 2021). This method enables the updating of prediction intervals whenever new observations are available. This dynamic update process allows the method to adapt to changing conditions, accounting for the potential degradation of predictions or the increase in noise levels in the data.</p><h2 id="The-Task-at-Hand"><a class="docs-heading-anchor" href="#The-Task-at-Hand">The Task at Hand</a><a id="The-Task-at-Hand-1"></a><a class="docs-heading-anchor-permalink" href="#The-Task-at-Hand" title="Permalink"></a></h2><p>Inspired by <a href="https://mapie.readthedocs.io/en/latest/examples_regression/4-tutorials/plot_ts-tutorial.html">MAPIE</a>, we employ the Victoria electricity demand dataset. This dataset contains hourly electricity demand (in GW) for Victoria state in Australia, along with corresponding temperature data (in Celsius degrees).</p><pre><code class="language-julia hljs">using CSV, DataFrames
df = CSV.read(&quot;./dev/artifacts/electricity_demand.csv&quot;, DataFrame)</code></pre><h2 id="Feature-engineering"><a class="docs-heading-anchor" href="#Feature-engineering">Feature engineering</a><a id="Feature-engineering-1"></a><a class="docs-heading-anchor-permalink" href="#Feature-engineering" title="Permalink"></a></h2><p>In this how-to guide, we only focus on date, time and lag features.</p><h3 id="Date-and-Time-related-features"><a class="docs-heading-anchor" href="#Date-and-Time-related-features">Date and Time-related features</a><a id="Date-and-Time-related-features-1"></a><a class="docs-heading-anchor-permalink" href="#Date-and-Time-related-features" title="Permalink"></a></h3><p>We create temporal features out of the date and hour:</p><pre><code class="language-julia hljs">using Dates
df.Datetime = Dates.DateTime.(df.Datetime, &quot;yyyy-mm-dd HH:MM:SS&quot;)
df.Weekofyear = Dates.week.(df.Datetime)
df.Weekday = Dates.dayofweek.(df.Datetime)
df.hour = Dates.hour.(df.Datetime) </code></pre><p>Additionally, to simulate sudden changes caused by unforeseen events, such as blackouts or lockdowns, we deliberately reduce the electricity demand by 2GW from February 22nd onward.</p><pre><code class="language-julia hljs">condition = df.Datetime .&gt;= Date(&quot;2014-02-22&quot;)
df[condition, :Demand] .= df[condition, :Demand] .- 2</code></pre><h3 id="Lag-features"><a class="docs-heading-anchor" href="#Lag-features">Lag features</a><a id="Lag-features-1"></a><a class="docs-heading-anchor-permalink" href="#Lag-features" title="Permalink"></a></h3><pre><code class="language-julia hljs">using ShiftedArrays
n_lags = 5
for i = 1:n_lags
    DataFrames.transform!(df, &quot;Demand&quot; =&gt; (x -&gt; ShiftedArrays.lag(x, i)) =&gt; &quot;lag_hour_$i&quot;)
end

df_dropped_missing = dropmissing(df)
df_dropped_missing</code></pre><h2 id="Train-test-split"><a class="docs-heading-anchor" href="#Train-test-split">Train-test split</a><a id="Train-test-split-1"></a><a class="docs-heading-anchor-permalink" href="#Train-test-split" title="Permalink"></a></h2><p>As usual, we split the data into train and test sets. We use the first 90% of the data for training and the remaining 10% for testing.</p><pre><code class="language-julia hljs">features_cols = DataFrames.select(df_dropped_missing, Not([:Datetime, :Demand]))
X = Matrix(features_cols)
y = Matrix(df_dropped_missing[:, [:Demand]])
split_index = floor(Int, 0.9 * size(y , 1)) 
println(split_index)
X_train = X[1:split_index, :]
y_train = y[1:split_index, :]
X_test = X[split_index+1 : size(y,1), :]
y_test = y[split_index+1 : size(y,1), :]</code></pre><h2 id="Loading-model-using-MLJ-interface"><a class="docs-heading-anchor" href="#Loading-model-using-MLJ-interface">Loading model using MLJ interface</a><a id="Loading-model-using-MLJ-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-model-using-MLJ-interface" title="Permalink"></a></h2><p>As our baseline model, we use a boosted tree regressor:</p><pre><code class="language-julia hljs">using MLJ
EvoTreeRegressor = @load EvoTreeRegressor pkg=EvoTrees verbosity=0
model = EvoTreeRegressor(nrounds =100, max_depth=10, rng=123)</code></pre><h2 id="Conformal-time-series"><a class="docs-heading-anchor" href="#Conformal-time-series">Conformal time series</a><a id="Conformal-time-series-1"></a><a class="docs-heading-anchor-permalink" href="#Conformal-time-series" title="Permalink"></a></h2><p>Next, we conformalize the model using EnbPI. First, we will proceed without updating training set residuals to build prediction intervals. The result is shown in the following figure:</p><pre><code class="language-julia hljs">using ConformalPrediction

conf_model = conformal_model(model; method=:time_series_ensemble_batch, coverage=0.95)
mach = machine(conf_model, X_train, y_train)
train = [1:split_index;]
fit!(mach, rows=train)

y_pred_interval = MLJ.predict(conf_model, mach.fitresult, X_test)
lb = [ minimum(tuple_data) for tuple_data in y_pred_interval]
ub = [ maximum(tuple_data) for tuple_data in y_pred_interval]
y_pred = [mean(tuple_data) for tuple_data in y_pred_interval]</code></pre><p><img src="../timeseries_files/figure-commonmark/cell-10-output-1.svg" alt/></p><p>We can use <code>partial_fit</code> method in EnbPI implementation in ConformalPrediction in order to adjust prediction intervals to sudden change points on test sets that have not been seen by the model during training. In the below experiment, sample<em>size indicates the batch of new observations. You can decide if you want to update residuals by sample</em>size or update and remove first <em>n</em> residuals (shift_size = n). The latter will allow to remove early residuals that will not have a positive impact on the current observations.</p><p>The chart below compares the results to the previous experiment without updating residuals:</p><pre><code class="language-julia hljs">sample_size = 10
shift_size = 10
last_index = size(X_test , 1)
lb_updated , ub_updated = ([], [])
for step in 1:sample_size:last_index
    if last_index - step &lt; sample_size
        y_interval = MLJ.predict(conf_model, mach.fitresult, X_test[step:last_index , :])
        partial_fit(mach.model , mach.fitresult, X_test[step:last_index , :], y_test[step:last_index , :], shift_size)
    else
        y_interval = MLJ.predict(conf_model, mach.fitresult, X_test[step:step+sample_size-1 , :])
        partial_fit(mach.model , mach.fitresult, X_test[step:step+sample_size-1 , :], y_test[step:step+sample_size-1 , :], shift_size)        
    end 
    lb_updated·µ¢= [ minimum(tuple_data) for tuple_data in y_interval]
    push!(lb_updated,lb_updated·µ¢)
    ub_updated·µ¢ = [ maximum(tuple_data) for tuple_data in y_interval]
    push!(ub_updated, ub_updated·µ¢)
end
lb_updated = reduce(vcat, lb_updated)
ub_updated = reduce(vcat, ub_updated)</code></pre><p><img src="../timeseries_files/figure-commonmark/cell-12-output-1.svg" alt/></p><h2 id="Results"><a class="docs-heading-anchor" href="#Results">Results</a><a id="Results-1"></a><a class="docs-heading-anchor-permalink" href="#Results" title="Permalink"></a></h2><p>In time series problems, unexpected incidents can lead to sudden changes, and such scenarios are highly probable. As illustrated earlier, the model‚Äôs training data lacks information about these change points, making it unable to anticipate them. The top figure demonstrates that when residuals are not updated, the prediction intervals solely rely on the distribution of residuals from the training set. Consequently, these intervals fail to encompass the true observations after the change point, resulting in a sudden drop in coverage.</p><p>However, by partially updating the residuals, the method becomes adept at capturing the increasing uncertainties in model predictions. It is important to note that the changes in uncertainty occur approximately one day after the change point. This delay is attributed to the requirement of having a sufficient number of new residuals to alter the quantiles obtained from the residual distribution.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><p>Xu, Chen, and Yao Xie. 2021. ‚ÄúConformal Prediction Interval for Dynamic Time-Series.‚Äù In, 11559‚Äì69. PMLR. <a href="https://proceedings.mlr.press/v139/xu21h.html">https://proceedings.mlr.press/v139/xu21h.html</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../llm/">¬´ How to Conformalize a Large Language Model</a><a class="docs-footer-nextpage" href="../../explanation/">Overview ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 8 September 2023 07:15">Friday 8 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
