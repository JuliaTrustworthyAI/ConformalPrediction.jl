---
format: 
  commonmark:
    variant: -raw_html
    wrap: none
    self-contained: true
crossref:
  fig-prefix: Figure
  tbl-prefix: Table
bibliography: https://raw.githubusercontent.com/pat-alt/bib/main/bib.bib
output: asis
execute: 
  output: false
  freeze: auto
  eval: true
  echo: true
jupyter: julia-1.7
---

```{julia}
#| echo: false
using Pkg; Pkg.activate("docs")
using Plots, PlotThemes
theme(:wong)
```


# Classification Tutorial

[INCOMPLETE]

We firstly generate some synthetic data with three classes and partition it into a training set, a calibration set and a test set:

```{julia}
using MLJ
X, y = MLJ.make_moons(1000)
train, calibration, test = partition(eachindex(y), 0.4, 0.4)
```

Following the standard [MLJ](https://alan-turing-institute.github.io/MLJ.jl/dev/) procedure, we train a decision tree for the classification task:

```{julia}
DecisionTreeClassifier = @load DecisionTreeClassifier pkg=DecisionTree
model = DecisionTreeClassifier() 
mach = machine(model, X, y)
fit!(mach, rows=train)
```

Next we instantiate our conformal model and calibrate using the calibration data:

```{julia}
using ConformalPrediction
conf_model = conformal_model(model)
calibrate!(conf_model, selectrows(X, calibration), y[calibration])
```

Using the generic `predict` method we can generate prediction sets like so:

```{julia}
#| output: true
predict(conf_model, selectrows(X, rand(test,5)))
```

```{julia}
coverage = 0.90
X_lim = map(i -> extrema(X[i]), eachindex(X))
X_grid = collect(map(x_lim -> range(x_lim..., length=30), X_lim))
label_grid = [Int.(predict_mode(conf_model.model, [x1 x2]).refs) for x1 in X_grid[1], x2 in X_grid[2]]
p_grid = [MLJ.pdf.(predict(conf_model.model, [x1 x2]), 1) for x1 in X_grid[1], x2 in X_grid[2]]
C_grid = [sum([!ismissing(val) for (key,val) in predict(conf_model, [x1 x2],coverage)[1]]) for x1 in X_grid[1], x2 in X_grid[2]]
```

```{julia}
using Plots
p_p = contourf(X_grid[1], X_grid[2], reduce(vcat, p_grid))
scatter!(X[:x1],X[:x2],colour=Int.(y.refs),group=Int.(y.refs))
p_label = contourf(X_grid[1], X_grid[2], reduce(vcat, label_grid))
scatter!(X[:x1],X[:x2],colour=Int.(y.refs),group=Int.(y.refs))
p_C = contourf(X_grid[1], X_grid[2], reduce(vcat, C_grid))
scatter!(X[:x1],X[:x2],colour=Int.(y.refs),group=Int.(y.refs))
plot(p_p, p_label, p_C, layout=(1,3), size=(900,210))
```


