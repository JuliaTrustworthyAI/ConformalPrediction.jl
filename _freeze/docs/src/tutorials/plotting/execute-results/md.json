{
  "hash": "39031b6bd27fe51b9617ed83b42ba0cf",
  "result": {
    "markdown": "# Visualization using `Plots.jl` recipes\n\n```@meta\nCurrentModule = ConformalPrediction\n```\n\n\n\nThis tutorial demonstrates how various custom `Plots.jl` recipes can be used to visually analyze conformal predictors. It is currently inclomplete.\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nusing ConformalPrediction\n```\n:::\n\n\n## Regression\n\n### Visualizing Predictions\n\n#### Univariate Input\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\nusing MLJ\nX, y = make_regression(100, 1; noise=0.3)\n```\n:::\n\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\nEvoTreeRegressor = @load EvoTreeRegressor pkg=EvoTrees\nmodel = EvoTreeRegressor() \nconf_model = conformal_model(model)\nmach = machine(conf_model, X, y)\nfit!(mach)\n```\n:::\n\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\nplot(mach.model, mach.fitresult, X, y; input_var=1)\n```\n:::\n\n\n#### Multivariate Input\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\nusing MLJ\nX, y = @load_boston\nschema(X)\n```\n:::\n\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\nEvoTreeRegressor = @load EvoTreeRegressor pkg=EvoTrees\nmodel = EvoTreeRegressor() \nconf_model = conformal_model(model)\nmach = machine(conf_model, X, y)\nfit!(mach)\n```\n:::\n\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\ninput_vars = [:Crim, :Age, :Tax]\nnvars = length(input_vars)\nplt_list = []\nfor input_var in input_vars\n    plt = plot(mach.model, mach.fitresult, X, y; input_var=input_var, title=input_var)\n    push!(plt_list, plt)\nend\nplot(plt_list..., layout=(1,nvars), size=(nvars*200, 200))\n```\n:::\n\n\n### Visualizing Set Size\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\nbar(mach.model, mach.fitresult, X)\n```\n:::\n\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\nEvoTreeRegressor = @load EvoTreeRegressor pkg=EvoTrees\nmodel = EvoTreeRegressor() \nconf_model = conformal_model(model, method=:jackknife_plus)\nmach = machine(conf_model, X, y)\nfit!(mach)\n```\n:::\n\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\nbar(mach.model, mach.fitresult, X)\n```\n:::\n\n\n## Classification\n\n::: {.cell execution_count=12}\n``` {.julia .cell-code}\nEvoTreeClassifier = @load EvoTreeClassifier pkg=EvoTrees\nmodel = EvoTreeClassifier() \n```\n:::\n\n\n### Visualizing Predictions\n\n#### Two-Dimensional Input\n\n::: {.cell execution_count=13}\n``` {.julia .cell-code}\nusing MLJ\nX, y = make_blobs(100, 2)\n```\n:::\n\n\n::: {.cell execution_count=14}\n``` {.julia .cell-code}\nconf_model = conformal_model(model)\nmach = machine(conf_model, X, y)\nfit!(mach)\n```\n:::\n\n\n::: {.cell execution_count=15}\n``` {.julia .cell-code}\np1 = contourf(mach.model, mach.fitresult, X, y)\np2 = contourf(mach.model, mach.fitresult, X, y; plot_set_size=true)\nplot(p1, p2, size=(700,300))\n```\n:::\n\n\n#### Multivariate Input\n\n::: {.cell execution_count=16}\n``` {.julia .cell-code}\nusing MLJ\nX, y = make_blobs(100, 4)\n```\n:::\n\n\n::: {.cell execution_count=17}\n``` {.julia .cell-code}\nEvoTreeClassifier = @load EvoTreeClassifier pkg=EvoTrees\nmodel = EvoTreeClassifier() \nconf_model = conformal_model(model)\nmach = machine(conf_model, X, y)\nfit!(mach)\n```\n:::\n\n\n[NOT YET IMPLEMENTED]\n\n### Visualizing Set Size\n\n::: {.cell execution_count=18}\n``` {.julia .cell-code}\n# Model:\nKNNClassifier = @load KNNClassifier pkg=NearestNeighborModels\nmodel = KNNClassifier(;K=50)\n```\n:::\n\n\n::: {.cell execution_count=19}\n``` {.julia .cell-code}\nX, y = make_moons(500)\n```\n:::\n\n\n::: {.cell execution_count=20}\n``` {.julia .cell-code}\nconf_model = conformal_model(model)\nmach = machine(conf_model, X, y)\nfit!(mach)\n```\n:::\n\n\n::: {.cell execution_count=21}\n``` {.julia .cell-code}\np1 = contourf(mach.model, mach.fitresult, X, y; plot_set_size=true)\np2 = bar(mach.model, mach.fitresult, X)\nplot(p1, p2, size=(700,300))\n```\n:::\n\n\n::: {.cell execution_count=22}\n``` {.julia .cell-code}\nconf_model = conformal_model(model, method=:adaptive_inductive)\nmach = machine(conf_model, X, y)\nfit!(mach)\n```\n:::\n\n\n::: {.cell execution_count=23}\n``` {.julia .cell-code}\np1 = contourf(mach.model, mach.fitresult, X, y; plot_set_size=true)\np2 = bar(mach.model, mach.fitresult, X)\nplot(p1, p2, size=(700,300))\n```\n:::\n\n\n",
    "supporting": [
      "plotting_files"
    ],
    "filters": []
  }
}