{
  "hash": "c56dcfed5fce5fece3f8dd90b08af0bd",
  "result": {
    "markdown": "```@meta\nCurrentModule = ConformalPrediction\n```\n\n# ConformalPrediction\n\nDocumentation for [ConformalPrediction.jl](https://github.com/pat-alt/ConformalPrediction.jl).\n\n\n\n`ConformalPrediction.jl` is a package for Uncertainty Quantification (UQ) through Conformal Prediction (CP) in Julia. It is designed to work with supervised models trained in [MLJ](https://alan-turing-institute.github.io/MLJ.jl/dev/). Conformal Prediction is distribution-free, easy-to-understand, easy-to-use and model-agnostic. \n\n## Disclaimer ⚠️\n\nThis package is in its very early stages of development. In fact, I've built this package largely to gain a better understanding of the topic myself. So far only the most simple approaches have been implemented:\n\n- Inductive Conformal Regression\n- Inductive Conformal Classification:  LABEL approach for classification [@sadinle2019least].\n- Naive Transductive Regression\n- Naive Transductive Classification\n- Jackknife Regression\n\nI have only tested it for a few of the supervised models offered by [MLJ](https://alan-turing-institute.github.io/MLJ.jl/dev/).\n\n## Installation 🚩\n\nYou can install the first stable release from the general registry:\n\n```julia\nusing Pkg\nPkg.add(\"ConformalPrediction\")\n```\n\nThe development version can be installed as follows:\n\n```julia\nusing Pkg\nPkg.add(url=\"https://github.com/pat-alt/ConformalPrediction.jl\")\n```\n\n## Usage Example - Inductive Conformal Regression 🔍\n\nTo illustrate the intended use of the package, let's have a quick look at a simple regression problem. Using [MLJ](https://alan-turing-institute.github.io/MLJ.jl/dev/) we first generate some synthetic data and then determine indices for our training, calibration and test data:\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nusing MLJ\nX, y = MLJ.make_regression(1000, 2)\ntrain, calibration, test = partition(eachindex(y), 0.4, 0.4)\n```\n:::\n\n\nWe then train a decision tree ([DecisionTree](https://github.com/Evovest/DecisionTree.jl)) and follow the standard [MLJ](https://alan-turing-institute.github.io/MLJ.jl/dev/) training procedure.\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\nDecisionTreeRegressor = @load DecisionTreeRegressor pkg=DecisionTree\nmodel = DecisionTreeRegressor() \n```\n:::\n\n\nTo turn our conventional machine into a conformal model, we just need to declare it as such by using `conformal_model` wrapper function. The generated conformal model instance can wrapped in data to create a *machine* following standard MLJ convention. By default that function instantiates a `SimpleInductiveRegressor`. \n\nFitting Inductive Conformal Predictors using `fit!` trains the underlying machine learning model, but it does not compute nonconformity scores. That is because Inductive Conformal Predictors rely on a separate set of calibration data. Consequently, conformal models of type `InductiveConformalModel <: ConformalModel` require a separate calibration step to be trained for conformal prediction. This can be implemented by calling the generic `calibrate!` method on the model instance. \n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\nusing ConformalPrediction\nconf_model = conformal_model(model)\nmach = machine(conf_model, X, y)\nfit!(mach, rows=train)\ncalibrate!(conf_model, selectrows(X, calibration), y[calibration])\n```\n:::\n\n\nPoint predictions for the underlying machine learning model can be computed as always using the generic `predict` method. The code below produces predictions a random subset of test samples:\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\nXtest = selectrows(X, rand(test,5))\npredict(mach, Xtest)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n╭────────────────────────────────────╮\n│                                    │\n│      (1)   -0.2490110619871871     │\n│      (2)   -1.0167269358933992     │\n│      (3)   -0.8519650726750141     │\n│      (4)   -0.3722576797642708     │\n│      (5)   -0.4839319169781634     │\n│                                    │\n│                                    │\n╰──────────────────────── 5 items ───╯\n```\n:::\n:::\n\n\nConformal prediction regions can be computed using the `predict_region` method:\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\ncoverage = .90\npredict_region(conf_model, Xtest, coverage)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n╭────────────────────────────────────────────────────────────────────╮\n│                                                                    │\n│      (1)   [\"lower\" => [-0.522312833437048], \"upper\" =>            │\n│  [0.024290709462673865]]                                           │\n│      (2)   [\"lower\" => [-1.2900287073432601], \"upper\" =>           │\n│  [-0.7434251644435383]]                                            │\n│      (3)   [\"lower\" => [-1.125266844124875], \"upper\" =>            │\n│  [-0.5786633012251532]]                                            │\n│      (4)   [\"lower\" => [-0.6455594512141318], \"upper\" =>           │\n│  [-0.09895590831440987]]                                           │\n│      (5)   [\"lower\" => [-0.7572336884280244], \"upper\" =>           │\n│  [-0.21063014552830245]]                                           │\n│                                                                    │\n│                                                                    │\n│                                                                    │\n╰──────────────────────────────────────────────────────── 5 items ───╯\n```\n:::\n:::\n\n\n## Contribute 🛠\n\nContributions are welcome! Please follow the [SciML ColPrac guide](https://github.com/SciML/ColPrac).\n\n## References 🎓\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": []
  }
}