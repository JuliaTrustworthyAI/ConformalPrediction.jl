<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>üßê Reference ¬∑ ConformalPrediction.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://juliatrustworthyai.github.io/ConformalPrediction.jl/_reference/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="ConformalPrediction.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ConformalPrediction.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">üè† Home</a></li><li><span class="tocitem">ü´£ Tutorials</span><ul><li><a class="tocitem" href="../tutorials/">Overview</a></li><li><a class="tocitem" href="../tutorials/classification/">Classification</a></li><li><a class="tocitem" href="../tutorials/regression/">Regression</a></li><li><a class="tocitem" href="../tutorials/plotting/">Visualizations</a></li></ul></li><li><span class="tocitem">ü´° How-To Guides</span><ul><li><a class="tocitem" href="../how_to_guides/">Overview</a></li><li><a class="tocitem" href="../how_to_guides/mnist/">How to Conformalize a Deep Image Classifier</a></li><li><a class="tocitem" href="../how_to_guides/llm/">How to Conformalize a Large Language Model</a></li></ul></li><li><span class="tocitem">ü§ì Explanation</span><ul><li><a class="tocitem" href="../explanation/">Overview</a></li><li><a class="tocitem" href="../explanation/architecture/">Package Architecture</a></li></ul></li><li class="is-active"><a class="tocitem" href>üßê Reference</a><ul class="internal"><li><a class="tocitem" href="#Content"><span>Content</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Public-Interface"><span>Public Interface</span></a></li><li><a class="tocitem" href="#Internal-functions"><span>Internal functions</span></a></li></ul></li><li><a class="tocitem" href="../contribute/">üõ† Contribute</a></li><li><a class="tocitem" href="../faq/">‚ùì FAQ</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>üßê Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>üßê Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/main/docs/src/_reference.md#" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><p>In this reference you will find a detailed overview of the package API.</p><blockquote><p>Reference guides are technical descriptions of the machinery and how to operate it. Reference material is information-oriented.</p><p>‚Äì- <a href="https://diataxis.fr/reference/">Di√°taxis</a></p></blockquote><p>In other words, you come here because you want to take a very close look at the code üßê</p><h2 id="Content"><a class="docs-heading-anchor" href="#Content">Content</a><a id="Content-1"></a><a class="docs-heading-anchor-permalink" href="#Content" title="Permalink"></a></h2><ul><li><a href="#Reference">Reference</a></li><li class="no-marker"><ul><li><a href="#Content">Content</a></li><li><a href="#Index">Index</a></li><li><a href="#Public-Interface">Public Interface</a></li><li><a href="#Internal-functions">Internal functions</a></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#ConformalPrediction.available_models"><code>ConformalPrediction.available_models</code></a></li><li><a href="#ConformalPrediction.tested_atomic_models"><code>ConformalPrediction.tested_atomic_models</code></a></li><li><a href="#ConformalPrediction.AdaptiveInductiveClassifier"><code>ConformalPrediction.AdaptiveInductiveClassifier</code></a></li><li><a href="#ConformalPrediction.CVMinMaxRegressor"><code>ConformalPrediction.CVMinMaxRegressor</code></a></li><li><a href="#ConformalPrediction.CVPlusRegressor"><code>ConformalPrediction.CVPlusRegressor</code></a></li><li><a href="#ConformalPrediction.ConformalInterval"><code>ConformalPrediction.ConformalInterval</code></a></li><li><a href="#ConformalPrediction.ConformalProbabilistic"><code>ConformalPrediction.ConformalProbabilistic</code></a></li><li><a href="#ConformalPrediction.ConformalProbabilisticSet"><code>ConformalPrediction.ConformalProbabilisticSet</code></a></li><li><a href="#ConformalPrediction.JackknifeMinMaxRegressor"><code>ConformalPrediction.JackknifeMinMaxRegressor</code></a></li><li><a href="#ConformalPrediction.JackknifePlusAbMinMaxRegressor"><code>ConformalPrediction.JackknifePlusAbMinMaxRegressor</code></a></li><li><a href="#ConformalPrediction.JackknifePlusAbRegressor"><code>ConformalPrediction.JackknifePlusAbRegressor</code></a></li><li><a href="#ConformalPrediction.JackknifePlusRegressor"><code>ConformalPrediction.JackknifePlusRegressor</code></a></li><li><a href="#ConformalPrediction.JackknifeRegressor"><code>ConformalPrediction.JackknifeRegressor</code></a></li><li><a href="#ConformalPrediction.NaiveClassifier"><code>ConformalPrediction.NaiveClassifier</code></a></li><li><a href="#ConformalPrediction.NaiveRegressor"><code>ConformalPrediction.NaiveRegressor</code></a></li><li><a href="#ConformalPrediction.SimpleInductiveClassifier"><code>ConformalPrediction.SimpleInductiveClassifier</code></a></li><li><a href="#ConformalPrediction.SimpleInductiveRegressor"><code>ConformalPrediction.SimpleInductiveRegressor</code></a></li><li><a href="#ConformalPrediction._aggregate-Tuple{Any, Union{String, Symbol}}"><code>ConformalPrediction._aggregate</code></a></li><li><a href="#ConformalPrediction.classification_loss-Tuple{ConformalPrediction.ConformalProbabilisticSet, Any, Any, Any}"><code>ConformalPrediction.classification_loss</code></a></li><li><a href="#ConformalPrediction.conformal_model-Tuple{MLJModelInterface.Supervised}"><code>ConformalPrediction.conformal_model</code></a></li><li><a href="#ConformalPrediction.emp_coverage-Tuple{Any, Any}"><code>ConformalPrediction.emp_coverage</code></a></li><li><a href="#ConformalPrediction.generate_lims-NTuple{5, Any}"><code>ConformalPrediction.generate_lims</code></a></li><li><a href="#ConformalPrediction.get_names-Tuple{Any}"><code>ConformalPrediction.get_names</code></a></li><li><a href="#ConformalPrediction.is_classification-Tuple{Any}"><code>ConformalPrediction.is_classification</code></a></li><li><a href="#ConformalPrediction.is_covered-Tuple{Any, Any}"><code>ConformalPrediction.is_covered</code></a></li><li><a href="#ConformalPrediction.is_covered_interval-Tuple{Any, Any}"><code>ConformalPrediction.is_covered_interval</code></a></li><li><a href="#ConformalPrediction.is_covered_set-Tuple{Any, Any}"><code>ConformalPrediction.is_covered_set</code></a></li><li><a href="#ConformalPrediction.is_regression-Tuple{Any}"><code>ConformalPrediction.is_regression</code></a></li><li><a href="#ConformalPrediction.reformat_interval-Tuple{Any}"><code>ConformalPrediction.reformat_interval</code></a></li><li><a href="#ConformalPrediction.reformat_mlj_prediction-Tuple{Any}"><code>ConformalPrediction.reformat_mlj_prediction</code></a></li><li><a href="#ConformalPrediction.score"><code>ConformalPrediction.score</code></a></li><li><a href="#ConformalPrediction.score"><code>ConformalPrediction.score</code></a></li><li><a href="#ConformalPrediction.score"><code>ConformalPrediction.score</code></a></li><li><a href="#ConformalPrediction.score"><code>ConformalPrediction.score</code></a></li><li><a href="#ConformalPrediction.score"><code>ConformalPrediction.score</code></a></li><li><a href="#ConformalPrediction.score"><code>ConformalPrediction.score</code></a></li><li><a href="#ConformalPrediction.score"><code>ConformalPrediction.score</code></a></li><li><a href="#ConformalPrediction.set_size-Tuple{Any}"><code>ConformalPrediction.set_size</code></a></li><li><a href="#ConformalPrediction.size_stratified_coverage-Tuple{Any, Any}"><code>ConformalPrediction.size_stratified_coverage</code></a></li><li><a href="#ConformalPrediction.smooth_size_loss-Tuple{ConformalPrediction.ConformalProbabilisticSet, Any, Any}"><code>ConformalPrediction.smooth_size_loss</code></a></li><li><a href="#ConformalPrediction.soft_assignment-Tuple{ConformalPrediction.ConformalProbabilisticSet}"><code>ConformalPrediction.soft_assignment</code></a></li><li><a href="#ConformalPrediction.soft_assignment-Tuple{ConformalPrediction.ConformalProbabilisticSet, Any, Any}"><code>ConformalPrediction.soft_assignment</code></a></li><li><a href="#ConformalPrediction.split_data-Tuple{ConformalPrediction.ConformalProbabilisticSet, Any, Any}"><code>ConformalPrediction.split_data</code></a></li><li><a href="#MLJModelInterface.fit-Tuple{ConformalPrediction.AdaptiveInductiveClassifier, Any, Any, Any}"><code>MLJModelInterface.fit</code></a></li><li><a href="#MLJModelInterface.fit-Tuple{ConformalPrediction.NaiveRegressor, Any, Any, Any}"><code>MLJModelInterface.fit</code></a></li><li><a href="#MLJModelInterface.fit-Tuple{ConformalPrediction.CVPlusRegressor, Any, Any, Any}"><code>MLJModelInterface.fit</code></a></li><li><a href="#MLJModelInterface.fit-Tuple{ConformalPrediction.SimpleInductiveClassifier, Any, Any, Any}"><code>MLJModelInterface.fit</code></a></li><li><a href="#MLJModelInterface.fit-Tuple{ConformalPrediction.JackknifeRegressor, Any, Any, Any}"><code>MLJModelInterface.fit</code></a></li><li><a href="#MLJModelInterface.fit-Tuple{ConformalPrediction.JackknifeMinMaxRegressor, Any, Any, Any}"><code>MLJModelInterface.fit</code></a></li><li><a href="#MLJModelInterface.fit-Tuple{ConformalPrediction.NaiveClassifier, Any, Any, Any}"><code>MLJModelInterface.fit</code></a></li><li><a href="#MLJModelInterface.fit-Tuple{ConformalPrediction.SimpleInductiveRegressor, Any, Any, Any}"><code>MLJModelInterface.fit</code></a></li><li><a href="#MLJModelInterface.fit-Tuple{ConformalPrediction.CVMinMaxRegressor, Any, Any, Any}"><code>MLJModelInterface.fit</code></a></li><li><a href="#MLJModelInterface.fit-Tuple{ConformalPrediction.JackknifePlusAbRegressor, Any, Any, Any}"><code>MLJModelInterface.fit</code></a></li><li><a href="#MLJModelInterface.fit-Tuple{ConformalPrediction.JackknifePlusRegressor, Any, Any, Any}"><code>MLJModelInterface.fit</code></a></li><li><a href="#MLJModelInterface.fit-Tuple{ConformalPrediction.JackknifePlusAbMinMaxRegressor, Any, Any, Any}"><code>MLJModelInterface.fit</code></a></li><li><a href="#MLJModelInterface.predict-Tuple{ConformalPrediction.JackknifeMinMaxRegressor, Any, Any}"><code>MLJModelInterface.predict</code></a></li><li><a href="#MLJModelInterface.predict-Tuple{ConformalPrediction.CVPlusRegressor, Any, Any}"><code>MLJModelInterface.predict</code></a></li><li><a href="#MLJModelInterface.predict-Tuple{ConformalPrediction.NaiveRegressor, Any, Any}"><code>MLJModelInterface.predict</code></a></li><li><a href="#MLJModelInterface.predict-Tuple{ConformalPrediction.AdaptiveInductiveClassifier, Any, Any}"><code>MLJModelInterface.predict</code></a></li><li><a href="#MLJModelInterface.predict-Tuple{ConformalPrediction.JackknifePlusAbMinMaxRegressor, Any, Any}"><code>MLJModelInterface.predict</code></a></li><li><a href="#MLJModelInterface.predict-Tuple{ConformalPrediction.CVMinMaxRegressor, Any, Any}"><code>MLJModelInterface.predict</code></a></li><li><a href="#MLJModelInterface.predict-Tuple{ConformalPrediction.JackknifeRegressor, Any, Any}"><code>MLJModelInterface.predict</code></a></li><li><a href="#MLJModelInterface.predict-Tuple{ConformalPrediction.SimpleInductiveClassifier, Any, Any}"><code>MLJModelInterface.predict</code></a></li><li><a href="#MLJModelInterface.predict-Tuple{ConformalPrediction.JackknifePlusAbRegressor, Any, Any}"><code>MLJModelInterface.predict</code></a></li><li><a href="#MLJModelInterface.predict-Tuple{ConformalPrediction.NaiveClassifier, Any, Any}"><code>MLJModelInterface.predict</code></a></li><li><a href="#MLJModelInterface.predict-Tuple{ConformalPrediction.SimpleInductiveRegressor, Any, Any}"><code>MLJModelInterface.predict</code></a></li><li><a href="#MLJModelInterface.predict-Tuple{ConformalPrediction.JackknifePlusRegressor, Any, Any}"><code>MLJModelInterface.predict</code></a></li><li><a href="#Plots.areaplot-Tuple{ConformalPrediction.ConformalProbabilisticSet, Any, Any, Any}"><code>Plots.areaplot</code></a></li><li><a href="#Plots.bar-Tuple{ConformalModel, Any, Any}"><code>Plots.bar</code></a></li><li><a href="#Plots.contourf-Tuple{ConformalPrediction.ConformalProbabilisticSet, Any, Any, Any}"><code>Plots.contourf</code></a></li><li><a href="#RecipesBase.plot-Tuple{ConformalPrediction.ConformalInterval, Any, Any, Any}"><code>RecipesBase.plot</code></a></li></ul><h2 id="Public-Interface"><a class="docs-heading-anchor" href="#Public-Interface">Public Interface</a><a id="Public-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Public-Interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.available_models" href="#ConformalPrediction.available_models"><code>ConformalPrediction.available_models</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><p>A container listing all available methods for conformal prediction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/conformal_models.jl#L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.tested_atomic_models" href="#ConformalPrediction.tested_atomic_models"><code>ConformalPrediction.tested_atomic_models</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><p>A container listing all atomic MLJ models that have been tested for use with this package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/conformal_models.jl#L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.conformal_model-Tuple{MLJModelInterface.Supervised}" href="#ConformalPrediction.conformal_model-Tuple{MLJModelInterface.Supervised}"><code>ConformalPrediction.conformal_model</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conformal_model(model::Supervised; method::Union{Nothing, Symbol}=nothing, kwargs...)</code></pre><p>A simple wrapper function that turns a <code>model::Supervised</code> into a conformal model. It accepts an optional key argument that can be used to specify the desired <code>method</code> for conformal prediction as well as additinal <code>kwargs...</code> specific to the <code>method</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/conformal_models.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.emp_coverage-Tuple{Any, Any}" href="#ConformalPrediction.emp_coverage-Tuple{Any, Any}"><code>ConformalPrediction.emp_coverage</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">emp_coverage(yÃÇ, y)</code></pre><p>Computes the empirical coverage for conformal predictions <code>yÃÇ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/evaluation/measures.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.set_size-Tuple{Any}" href="#ConformalPrediction.set_size-Tuple{Any}"><code>ConformalPrediction.set_size</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_size(yÃÇ)</code></pre><p>Helper function that computes the set size for conformal predictions. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/utils.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.size_stratified_coverage-Tuple{Any, Any}" href="#ConformalPrediction.size_stratified_coverage-Tuple{Any, Any}"><code>ConformalPrediction.size_stratified_coverage</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">size_stratified_coverage(yÃÇ, y)</code></pre><p>Computes the size-stratified coverage for conformal predictions <code>yÃÇ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/evaluation/measures.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.soft_assignment-Tuple{ConformalPrediction.ConformalProbabilisticSet, Any, Any}" href="#ConformalPrediction.soft_assignment-Tuple{ConformalPrediction.ConformalProbabilisticSet, Any, Any}"><code>ConformalPrediction.soft_assignment</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">soft_assignment(conf_model::ConformalProbabilisticSet, fitresult, X; temp::Real=0.5)</code></pre><p>This function can be used to compute soft assigment probabilities for new data <code>X</code> as in <a href="#ConformalPrediction.soft_assignment-Tuple{ConformalPrediction.ConformalProbabilisticSet}"><code>soft_assignment(conf_model::ConformalProbabilisticSet; temp::Real=0.5)</code></a>. When a fitted model <span>$\mu$</span> (<code>fitresult</code>) and new samples <code>X</code> are supplied, non-conformity scores are first computed for the new data points. Then the existing threshold/quantile <code>qÃÇ</code> is used to compute the final soft assignments. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/training/losses.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.soft_assignment-Tuple{ConformalPrediction.ConformalProbabilisticSet}" href="#ConformalPrediction.soft_assignment-Tuple{ConformalPrediction.ConformalProbabilisticSet}"><code>ConformalPrediction.soft_assignment</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">soft_assignment(conf_model::ConformalProbabilisticSet; temp::Real=0.5)</code></pre><p>Computes soft assignment scores for each label and sample. That is, the probability of label <code>k</code> being included in the confidence set. This implementation follows Stutz et al. (2022): https://openreview.net/pdf?id=t8O-4LKFVx. Contrary to the paper, we use non-conformity scores instead of conformity scores, hence the sign swap. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/training/losses.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJModelInterface.fit-Tuple{ConformalPrediction.AdaptiveInductiveClassifier, Any, Any, Any}" href="#MLJModelInterface.fit-Tuple{ConformalPrediction.AdaptiveInductiveClassifier, Any, Any, Any}"><code>MLJModelInterface.fit</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MMI.fit(conf_model::AdaptiveInductiveClassifier, verbosity, X, y)</code></pre><p>For the <a href="#ConformalPrediction.AdaptiveInductiveClassifier"><code>AdaptiveInductiveClassifier</code></a> nonconformity scores are computed by cumulatively summing the ranked scores of each label in descending order until reaching the true label <span>$Y_i$</span>:</p><p><span>$S_i^{\text{CAL}} = s(X_i,Y_i) = \sum_{j=1}^k  \hat\mu(X_i)_{\pi_j} \ \text{where } \ Y_i=\pi_k,  i \in \mathcal{D}_{\text{calibration}}$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/inductive_classification.jl#L150-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJModelInterface.fit-Tuple{ConformalPrediction.CVMinMaxRegressor, Any, Any, Any}" href="#MLJModelInterface.fit-Tuple{ConformalPrediction.CVMinMaxRegressor, Any, Any, Any}"><code>MLJModelInterface.fit</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MMI.fit(conf_model::CVMinMaxRegressor, verbosity, X, y)</code></pre><p>For the <a href="#ConformalPrediction.CVMinMaxRegressor"><code>CVMinMaxRegressor</code></a> nonconformity scores are computed in the same way as for the <a href="#ConformalPrediction.CVPlusRegressor"><code>CVPlusRegressor</code></a>. Specifically, we have,</p><p><span>$S_i^{\text{CV}} = s(X_i, Y_i) = h(\hat\mu_{-\mathcal{D}_{k(i)}}(X_i), Y_i), \ i \in \mathcal{D}_{\text{train}}$</span></p><p>where <span>$\hat\mu_{-\mathcal{D}_{k(i)}}(X_i)$</span> denotes the CV prediction for <span>$X_i$</span>. In other words, for each CV fold <span>$k=1,...,K$</span> and each training instance <span>$i=1,...,n$</span> the model is trained on all training data excluding the fold containing <span>$i$</span>. The fitted model is then used to predict out-of-sample from <span>$X_i$</span>. The corresponding nonconformity score is then computed by applying a heuristic uncertainty measure <span>$h(\cdot)$</span> to the fitted value <span>$\hat\mu_{-\mathcal{D}_{k(i)}}(X_i)$</span> and the true value <span>$Y_i$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/transductive_regression.jl#L461-L471">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJModelInterface.fit-Tuple{ConformalPrediction.CVPlusRegressor, Any, Any, Any}" href="#MLJModelInterface.fit-Tuple{ConformalPrediction.CVPlusRegressor, Any, Any, Any}"><code>MLJModelInterface.fit</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MMI.fit(conf_model::CVPlusRegressor, verbosity, X, y)</code></pre><p>For the <a href="#ConformalPrediction.CVPlusRegressor"><code>CVPlusRegressor</code></a> nonconformity scores are computed though cross-validation (CV) as follows,</p><p><span>$S_i^{\text{CV}} = s(X_i, Y_i) = h(\hat\mu_{-\mathcal{D}_{k(i)}}(X_i), Y_i), \ i \in \mathcal{D}_{\text{train}}$</span></p><p>where <span>$\hat\mu_{-\mathcal{D}_{k(i)}}(X_i)$</span> denotes the CV prediction for <span>$X_i$</span>. In other words, for each CV fold <span>$k=1,...,K$</span> and each training instance <span>$i=1,...,n$</span> the model is trained on all training data excluding the fold containing <span>$i$</span>. The fitted model is then used to predict out-of-sample from <span>$X_i$</span>. The corresponding nonconformity score is then computed by applying a heuristic uncertainty measure <span>$h(\cdot)$</span> to the fitted value <span>$\hat\mu_{-\mathcal{D}_{k(i)}}(X_i)$</span> and the true value <span>$Y_i$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/transductive_regression.jl#L356-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJModelInterface.fit-Tuple{ConformalPrediction.JackknifeMinMaxRegressor, Any, Any, Any}" href="#MLJModelInterface.fit-Tuple{ConformalPrediction.JackknifeMinMaxRegressor, Any, Any, Any}"><code>MLJModelInterface.fit</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MMI.fit(conf_model::JackknifeMinMaxRegressor, verbosity, X, y)</code></pre><p>For the <a href="#ConformalPrediction.JackknifeMinMaxRegressor"><code>JackknifeMinMaxRegressor</code></a> nonconformity scores are computed in the same way as for the <a href="#ConformalPrediction.JackknifeRegressor"><code>JackknifeRegressor</code></a>. Specifically, we have,</p><p><span>$S_i^{\text{LOO}} = s(X_i, Y_i) = h(\hat\mu_{-i}(X_i), Y_i), \ i \in \mathcal{D}_{\text{train}}$</span></p><p>where <span>$\hat\mu_{-i}(X_i)$</span> denotes the leave-one-out prediction for <span>$X_i$</span>. In other words, for each training instance <span>$i=1,...,n$</span> the model is trained on all training data excluding <span>$i$</span>. The fitted model is then used to predict out-of-sample from <span>$X_i$</span>. The corresponding nonconformity score is then computed by applying a heuristic uncertainty measure <span>$h(\cdot)$</span> to the fitted value <span>$\hat\mu_{-i}(X_i)$</span> and the true value <span>$Y_i$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/transductive_regression.jl#L264-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJModelInterface.fit-Tuple{ConformalPrediction.JackknifePlusAbMinMaxRegressor, Any, Any, Any}" href="#MLJModelInterface.fit-Tuple{ConformalPrediction.JackknifePlusAbMinMaxRegressor, Any, Any, Any}"><code>MLJModelInterface.fit</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MMI.fit(conf_model::JackknifePlusMinMaxAbRegressor, verbosity, X, y)</code></pre><p>For the <a href="@ref"><code>JackknifePlusABMinMaxRegressor</code></a> nonconformity scores are as,</p><p><span>$S_i^{\text{J+MinMax}} = s(X_i, Y_i) = h(agg(\hat\mu_{B_{K(-i)}}(X_i)), Y_i), \ i \in \mathcal{D}_{\text{train}}$</span></p><p>where <span>$agg(\hat\mu_{B_{K(-i)}}(X_i))$</span> denotes the aggregate predictions, typically mean or median, for each <span>$X_i$</span> (with <span>$K_{-i}$</span> the bootstraps not containing <span>$X_i$</span>). In other words, B models are trained on boostrapped sampling, the fitted models are then used to create aggregated prediction of out-of-sample <span>$X_i$</span>. The corresponding nonconformity score is then computed by applying a heuristic uncertainty measure <span>$h(\cdot)$</span> to the fitted value <span>$agg(\hat\mu_{B_{K(-i)}}(X_i))$</span> and the true value <span>$Y_i$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/transductive_regression.jl#L700-L710">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJModelInterface.fit-Tuple{ConformalPrediction.JackknifePlusAbRegressor, Any, Any, Any}" href="#MLJModelInterface.fit-Tuple{ConformalPrediction.JackknifePlusAbRegressor, Any, Any, Any}"><code>MLJModelInterface.fit</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MMI.fit(conf_model::JackknifePlusAbRegressor, verbosity, X, y)</code></pre><p>For the <a href="#ConformalPrediction.JackknifePlusAbRegressor"><code>JackknifePlusAbRegressor</code></a> nonconformity scores are computed as</p><p><span>$$ S_i^{\text{J+ab}} = s(X_i, Y_i) = h(agg(\hat\mu_{B_{K(-i)}}(X_i)), Y_i), \ i \in \mathcal{D}_{\text{train}} $$</span></p><p>where <span>$agg(\hat\mu_{B_{K(-i)}}(X_i))$</span> denotes the aggregate predictions, typically mean or median, for each <span>$X_i$</span> (with <span>$K_{-i}$</span> the bootstraps not containing <span>$X_i$</span>). In other words, B models are trained on boostrapped sampling, the fitted models are then used to create aggregated prediction of out-of-sample <span>$X_i$</span>. The corresponding nonconformity score is then computed by applying a heuristic uncertainty measure <span>$h(\cdot)$</span> to the fitted value <span>$agg(\hat\mu_{B_{K(-i)}}(X_i))$</span> and the true value <span>$Y_i$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/transductive_regression.jl#L594-L604">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJModelInterface.fit-Tuple{ConformalPrediction.JackknifePlusRegressor, Any, Any, Any}" href="#MLJModelInterface.fit-Tuple{ConformalPrediction.JackknifePlusRegressor, Any, Any, Any}"><code>MLJModelInterface.fit</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MMI.fit(conf_model::JackknifePlusRegressor, verbosity, X, y)</code></pre><p>For the <a href="#ConformalPrediction.JackknifePlusRegressor"><code>JackknifePlusRegressor</code></a> nonconformity scores are computed in the same way as for the <a href="#ConformalPrediction.JackknifeRegressor"><code>JackknifeRegressor</code></a>. Specifically, we have,</p><p><span>$S_i^{\text{LOO}} = s(X_i, Y_i) = h(\hat\mu_{-i}(X_i), Y_i), \ i \in \mathcal{D}_{\text{train}}$</span></p><p>where <span>$\hat\mu_{-i}(X_i)$</span> denotes the leave-one-out prediction for <span>$X_i$</span>. In other words, for each training instance <span>$i=1,...,n$</span> the model is trained on all training data excluding <span>$i$</span>. The fitted model is then used to predict out-of-sample from <span>$X_i$</span>. The corresponding nonconformity score is then computed by applying a heuristic uncertainty measure <span>$h(\cdot)$</span> to the fitted value <span>$\hat\mu_{-i}(X_i)$</span> and the true value <span>$Y_i$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/transductive_regression.jl#L173-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJModelInterface.fit-Tuple{ConformalPrediction.JackknifeRegressor, Any, Any, Any}" href="#MLJModelInterface.fit-Tuple{ConformalPrediction.JackknifeRegressor, Any, Any, Any}"><code>MLJModelInterface.fit</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MMI.fit(conf_model::JackknifeRegressor, verbosity, X, y)</code></pre><p>For the <a href="#ConformalPrediction.JackknifeRegressor"><code>JackknifeRegressor</code></a> nonconformity scores are computed through a leave-one-out (LOO) procedure as follows,</p><p><span>$S_i^{\text{LOO}} = s(X_i, Y_i) = h(\hat\mu_{-i}(X_i), Y_i), \ i \in \mathcal{D}_{\text{train}}$</span></p><p>where <span>$\hat\mu_{-i}(X_i)$</span> denotes the leave-one-out prediction for <span>$X_i$</span>. In other words, for each training instance <span>$i=1,...,n$</span> the model is trained on all training data excluding <span>$i$</span>. The fitted model is then used to predict out-of-sample from <span>$X_i$</span>. The corresponding nonconformity score is then computed by applying a heuristic uncertainty measure <span>$h(\cdot)$</span> to the fitted value <span>$\hat\mu_{-i}(X_i)$</span> and the true value <span>$Y_i$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/transductive_regression.jl#L91-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJModelInterface.fit-Tuple{ConformalPrediction.NaiveClassifier, Any, Any, Any}" href="#MLJModelInterface.fit-Tuple{ConformalPrediction.NaiveClassifier, Any, Any, Any}"><code>MLJModelInterface.fit</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MMI.fit(conf_model::NaiveClassifier, verbosity, X, y)</code></pre><p>For the <a href="#ConformalPrediction.NaiveClassifier"><code>NaiveClassifier</code></a> nonconformity scores are computed in-sample as follows:</p><p><span>$S_i^{\text{IS}} = s(X_i, Y_i) = h(\hat\mu(X_i), Y_i), \ i \in \mathcal{D}_{\text{calibration}}$</span></p><p>A typical choice for the heuristic function is <span>$h(\hat\mu(X_i), Y_i)=1-\hat\mu(X_i)_{Y_i}$</span> where <span>$\hat\mu(X_i)_{Y_i}$</span> denotes the softmax output of the true class and <span>$\hat\mu$</span> denotes the model fitted on training data <span>$\mathcal{D}_{\text{train}}$</span>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/transductive_classification.jl#L16-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJModelInterface.fit-Tuple{ConformalPrediction.NaiveRegressor, Any, Any, Any}" href="#MLJModelInterface.fit-Tuple{ConformalPrediction.NaiveRegressor, Any, Any, Any}"><code>MLJModelInterface.fit</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MMI.fit(conf_model::NaiveRegressor, verbosity, X, y)</code></pre><p>For the <a href="#ConformalPrediction.NaiveRegressor"><code>NaiveRegressor</code></a> nonconformity scores are computed in-sample as follows:</p><p><span>$S_i^{\text{IS}} = s(X_i, Y_i) = h(\hat\mu(X_i), Y_i), \ i \in \mathcal{D}_{\text{train}}$</span></p><p>A typical choice for the heuristic function is <span>$h(\hat\mu(X_i),Y_i)=|Y_i-\hat\mu(X_i)|$</span> where <span>$\hat\mu$</span> denotes the model fitted on training data <span>$\mathcal{D}_{\text{train}}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/transductive_regression.jl#L23-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJModelInterface.fit-Tuple{ConformalPrediction.SimpleInductiveClassifier, Any, Any, Any}" href="#MLJModelInterface.fit-Tuple{ConformalPrediction.SimpleInductiveClassifier, Any, Any, Any}"><code>MLJModelInterface.fit</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MMI.fit(conf_model::SimpleInductiveClassifier, verbosity, X, y)</code></pre><p>For the <a href="#ConformalPrediction.SimpleInductiveClassifier"><code>SimpleInductiveClassifier</code></a> nonconformity scores are computed as follows:</p><p><span>$S_i^{\text{CAL}} = s(X_i, Y_i) = h(\hat\mu(X_i), Y_i), \ i \in \mathcal{D}_{\text{calibration}}$</span></p><p>A typical choice for the heuristic function is <span>$h(\hat\mu(X_i), Y_i)=1-\hat\mu(X_i)_{Y_i}$</span> where <span>$\hat\mu(X_i)_{Y_i}$</span> denotes the softmax output of the true class and <span>$\hat\mu$</span> denotes the model fitted on training data <span>$\mathcal{D}_{\text{train}}$</span>. The simple approach only takes the softmax probability of the true label into account.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/inductive_classification.jl#L74-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJModelInterface.fit-Tuple{ConformalPrediction.SimpleInductiveRegressor, Any, Any, Any}" href="#MLJModelInterface.fit-Tuple{ConformalPrediction.SimpleInductiveRegressor, Any, Any, Any}"><code>MLJModelInterface.fit</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MMI.fit(conf_model::SimpleInductiveRegressor, verbosity, X, y)</code></pre><p>For the <a href="#ConformalPrediction.SimpleInductiveRegressor"><code>SimpleInductiveRegressor</code></a> nonconformity scores are computed as follows:</p><p><span>$S_i^{\text{CAL}} = s(X_i, Y_i) = h(\hat\mu(X_i), Y_i), \ i \in \mathcal{D}_{\text{calibration}}$</span></p><p>A typical choice for the heuristic function is <span>$h(\hat\mu(X_i),Y_i)=|Y_i-\hat\mu(X_i)|$</span> where <span>$\hat\mu$</span> denotes the model fitted on training data <span>$\mathcal{D}_{\text{train}}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/inductive_regression.jl#L19-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJModelInterface.predict-Tuple{ConformalPrediction.AdaptiveInductiveClassifier, Any, Any}" href="#MLJModelInterface.predict-Tuple{ConformalPrediction.AdaptiveInductiveClassifier, Any, Any}"><code>MLJModelInterface.predict</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MMI.predict(conf_model::AdaptiveInductiveClassifier, fitresult, Xnew)</code></pre><p>For the <a href="#ConformalPrediction.AdaptiveInductiveClassifier"><code>AdaptiveInductiveClassifier</code></a> prediction sets are computed as follows,</p><p><span>$\hat{C}_{n,\alpha}(X_{n+1}) = \left\{y: s(X_{n+1},y) \le \hat{q}_{n, \alpha}^{+} \{S_i^{\text{CAL}}\} \right\},  i \in \mathcal{D}_{\text{calibration}}$</span></p><p>where <span>$\mathcal{D}_{\text{calibration}}$</span> denotes the designated calibration data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/inductive_classification.jl#L204-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJModelInterface.predict-Tuple{ConformalPrediction.CVMinMaxRegressor, Any, Any}" href="#MLJModelInterface.predict-Tuple{ConformalPrediction.CVMinMaxRegressor, Any, Any}"><code>MLJModelInterface.predict</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MMI.predict(conf_model::CVMinMaxRegressor, fitresult, Xnew)</code></pre><p>For the <a href="#ConformalPrediction.CVMinMaxRegressor"><code>CVMinMaxRegressor</code></a> prediction intervals are computed as follows,</p><p><span>$\hat{C}_{n,\alpha}(X_{n+1}) = \left[ \min_{i=1,...,n} \hat\mu_{-\mathcal{D}_{k(i)}}(X_{n+1}) -  \hat{q}_{n, \alpha}^{+} \{S_i^{\text{CV}} \}, \max_{i=1,...,n} \hat\mu_{-\mathcal{D}_{k(i)}}(X_{n+1}) + \hat{q}_{n, \alpha}^{+} \{ S_i^{\text{CV}}\} \right] , i \in \mathcal{D}_{\text{train}}$</span></p><p>where <span>$\hat\mu_{-\mathcal{D}_{k(i)}}$</span> denotes the model fitted on training data with subset <span>$\mathcal{D}_{k(i)}$</span> that contains the <span>$i$</span> th point removed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/transductive_regression.jl#L515-L525">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJModelInterface.predict-Tuple{ConformalPrediction.CVPlusRegressor, Any, Any}" href="#MLJModelInterface.predict-Tuple{ConformalPrediction.CVPlusRegressor, Any, Any}"><code>MLJModelInterface.predict</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MMI.predict(conf_model::CVPlusRegressor, fitresult, Xnew)</code></pre><p>For the <a href="#ConformalPrediction.CVPlusRegressor"><code>CVPlusRegressor</code></a> prediction intervals are computed in much same way as for the <a href="#ConformalPrediction.JackknifePlusRegressor"><code>JackknifePlusRegressor</code></a>. Specifically, we have,</p><p><span>$\hat{C}_{n,\alpha}(X_{n+1}) = \left[ \hat{q}_{n, \alpha}^{-} \{\hat\mu_{-\mathcal{D}_{k(i)}}(X_{n+1}) - S_i^{\text{CV}} \}, \hat{q}_{n, \alpha}^{+} \{\hat\mu_{-\mathcal{D}_{k(i)}}(X_{n+1}) + S_i^{\text{CV}}\} \right] , \ i \in \mathcal{D}_{\text{train}}$</span></p><p>where <span>$\hat\mu_{-\mathcal{D}_{k(i)}}$</span> denotes the model fitted on training data with fold <span>$\mathcal{D}_{k(i)}$</span> that contains the <span>$i$</span> th point removed. </p><p>The <a href="#ConformalPrediction.JackknifePlusRegressor"><code>JackknifePlusRegressor</code></a> is a special case of the <a href="#ConformalPrediction.CVPlusRegressor"><code>CVPlusRegressor</code></a> for which <span>$K=n$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/transductive_regression.jl#L410-L422">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJModelInterface.predict-Tuple{ConformalPrediction.JackknifeMinMaxRegressor, Any, Any}" href="#MLJModelInterface.predict-Tuple{ConformalPrediction.JackknifeMinMaxRegressor, Any, Any}"><code>MLJModelInterface.predict</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MMI.predict(conf_model::JackknifeMinMaxRegressor, fitresult, Xnew)</code></pre><p>For the <a href="#ConformalPrediction.JackknifeMinMaxRegressor"><code>JackknifeMinMaxRegressor</code></a> prediction intervals are computed as follows,</p><p><span>$\hat{C}_{n,\alpha}(X_{n+1}) = \left[ \min_{i=1,...,n} \hat\mu_{-i}(X_{n+1}) -  \hat{q}_{n, \alpha}^{+} \{S_i^{\text{LOO}} \}, \max_{i=1,...,n} \hat\mu_{-i}(X_{n+1}) + \hat{q}_{n, \alpha}^{+} \{S_i^{\text{LOO}}\} \right] ,  i \in \mathcal{D}_{\text{train}}$</span></p><p>where <span>$\hat\mu_{-i}$</span> denotes the model fitted on training data with <span>$i$</span>th point removed. The jackknife-minmax procedure is more conservative than the <a href="#ConformalPrediction.JackknifePlusRegressor"><code>JackknifePlusRegressor</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/transductive_regression.jl#L308-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJModelInterface.predict-Tuple{ConformalPrediction.JackknifePlusAbMinMaxRegressor, Any, Any}" href="#MLJModelInterface.predict-Tuple{ConformalPrediction.JackknifePlusAbMinMaxRegressor, Any, Any}"><code>MLJModelInterface.predict</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MMI.predict(conf_model::JackknifePlusAbMinMaxRegressor, fitresult, Xnew)</code></pre><p>For the <a href="#ConformalPrediction.JackknifePlusAbMinMaxRegressor"><code>JackknifePlusAbMinMaxRegressor</code></a> prediction intervals are computed as follows,</p><p><span>$\hat{C}_{n,\alpha}^{J+MinMax}(X_{n+1}) = \left[ \min_{i=1,...,n} \hat\mu_{-i}(X_{n+1}) -  \hat{q}_{n, \alpha}^{+} \{S_i^{\text{J+MinMax}} \}, \max_{i=1,...,n} \hat\mu_{-i}(X_{n+1}) + \hat{q}_{n, \alpha}^{+} \{S_i^{\text{J+MinMax}}\} \right] ,  i \in \mathcal{D}_{\text{train}}$</span></p><p>where <span>$\hat\mu_{-i}$</span> denotes the model fitted on training data with <span>$i$</span>th point removed. The jackknife+ab-minmax procedure is more conservative than the <a href="#ConformalPrediction.JackknifePlusAbRegressor"><code>JackknifePlusAbRegressor</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/transductive_regression.jl#L751-L761">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJModelInterface.predict-Tuple{ConformalPrediction.JackknifePlusAbRegressor, Any, Any}" href="#MLJModelInterface.predict-Tuple{ConformalPrediction.JackknifePlusAbRegressor, Any, Any}"><code>MLJModelInterface.predict</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MMI.predict(conf_model::JackknifePlusAbRegressor, fitresult, Xnew)</code></pre><p>For the <a href="#ConformalPrediction.JackknifePlusAbRegressor"><code>JackknifePlusAbRegressor</code></a> prediction intervals are computed as follows,</p><p><span>$\hat{C}_{n,\alpha, B}^{J+ab}(X_{n+1}) = \left[ \hat{q}_{n, \alpha}^{-} \{\hat\mu_{agg(-i)}(X_{n+1}) - S_i^{\text{J+ab}} \}, \hat{q}_{n, \alpha}^{+} \{\hat\mu_{agg(-i)}(X_{n+1}) + S_i^{\text{J+ab}}\} \right] , i \in \mathcal{D}_{\text{train}}$</span></p><p>where <span>$\hat\mu_{agg(-i)}$</span> denotes the aggregated models <span>$\hat\mu_{1}, ...., \hat\mu_{B}$</span> fitted on bootstrapped data (B) does not include the <span>$i$</span>th data point. The jackknife<span>$+$</span> procedure is more stable than the <a href="#ConformalPrediction.JackknifeRegressor"><code>JackknifeRegressor</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/transductive_regression.jl#L645-L655">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJModelInterface.predict-Tuple{ConformalPrediction.JackknifePlusRegressor, Any, Any}" href="#MLJModelInterface.predict-Tuple{ConformalPrediction.JackknifePlusRegressor, Any, Any}"><code>MLJModelInterface.predict</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MMI.predict(conf_model::JackknifePlusRegressor, fitresult, Xnew)</code></pre><p>For the <a href="#ConformalPrediction.JackknifePlusRegressor"><code>JackknifePlusRegressor</code></a> prediction intervals are computed as follows,</p><p><span>$\hat{C}_{n,\alpha}(X_{n+1}) = \left[ \hat{q}_{n, \alpha}^{-} \{\hat\mu_{-i}(X_{n+1}) - S_i^{\text{LOO}} \}, \hat{q}_{n, \alpha}^{+} \{\hat\mu_{-i}(X_{n+1}) + S_i^{\text{LOO}}\} \right] , i \in \mathcal{D}_{\text{train}}$</span></p><p>where <span>$\hat\mu_{-i}$</span> denotes the model fitted on training data with <span>$i$</span>th point removed. The jackknife<span>$+$</span> procedure is more stable than the <a href="#ConformalPrediction.JackknifeRegressor"><code>JackknifeRegressor</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/transductive_regression.jl#L217-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJModelInterface.predict-Tuple{ConformalPrediction.JackknifeRegressor, Any, Any}" href="#MLJModelInterface.predict-Tuple{ConformalPrediction.JackknifeRegressor, Any, Any}"><code>MLJModelInterface.predict</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MMI.predict(conf_model::JackknifeRegressor, fitresult, Xnew)</code></pre><p>For the <a href="#ConformalPrediction.JackknifeRegressor"><code>JackknifeRegressor</code></a> prediction intervals are computed as follows,</p><p><span>$\hat{C}_{n,\alpha}(X_{n+1}) = \hat\mu(X_{n+1}) \pm \hat{q}_{n, \alpha}^{+} \{S_i^{\text{LOO}}\}, \ i \in \mathcal{D}_{\text{train}}$</span></p><p>where <span>$S_i^{\text{LOO}}$</span> denotes the nonconformity that is generated as explained in <a href="#MLJModelInterface.fit-Tuple{ConformalPrediction.JackknifeRegressor, Any, Any, Any}"><code>fit(conf_model::JackknifeRegressor, verbosity, X, y)</code></a>. The jackknife procedure addresses the overfitting issue associated with the <a href="#ConformalPrediction.NaiveRegressor"><code>NaiveRegressor</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/transductive_regression.jl#L134-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJModelInterface.predict-Tuple{ConformalPrediction.NaiveClassifier, Any, Any}" href="#MLJModelInterface.predict-Tuple{ConformalPrediction.NaiveClassifier, Any, Any}"><code>MLJModelInterface.predict</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MMI.predict(conf_model::NaiveClassifier, fitresult, Xnew)</code></pre><p>For the <a href="#ConformalPrediction.NaiveClassifier"><code>NaiveClassifier</code></a> prediction sets are computed as follows:</p><p><span>$\hat{C}_{n,\alpha}(X_{n+1}) = \left\{y: s(X_{n+1},y) \le \hat{q}_{n, \alpha}^{+} \{S_i^{\text{IS}} \} \right\}, \ i \in \mathcal{D}_{\text{train}}$</span></p><p>The naive approach typically produces prediction regions that undercover due to overfitting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/transductive_classification.jl#L48-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJModelInterface.predict-Tuple{ConformalPrediction.NaiveRegressor, Any, Any}" href="#MLJModelInterface.predict-Tuple{ConformalPrediction.NaiveRegressor, Any, Any}"><code>MLJModelInterface.predict</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MMI.predict(conf_model::NaiveRegressor, fitresult, Xnew)</code></pre><p>For the <a href="#ConformalPrediction.NaiveRegressor"><code>NaiveRegressor</code></a> prediction intervals are computed as follows:</p><p><span>$\hat{C}_{n,\alpha}(X_{n+1}) = \hat\mu(X_{n+1}) \pm \hat{q}_{n, \alpha}^{+} \{S_i^{\text{IS}} \}, \ i \in \mathcal{D}_{\text{train}}$</span></p><p>The naive approach typically produces prediction regions that undercover due to overfitting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/transductive_regression.jl#L52-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJModelInterface.predict-Tuple{ConformalPrediction.SimpleInductiveClassifier, Any, Any}" href="#MLJModelInterface.predict-Tuple{ConformalPrediction.SimpleInductiveClassifier, Any, Any}"><code>MLJModelInterface.predict</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MMI.predict(conf_model::SimpleInductiveClassifier, fitresult, Xnew)</code></pre><p>For the <a href="#ConformalPrediction.SimpleInductiveClassifier"><code>SimpleInductiveClassifier</code></a> prediction sets are computed as follows,</p><p><span>$\hat{C}_{n,\alpha}(X_{n+1}) = \left\{y: s(X_{n+1},y) \le \hat{q}_{n, \alpha}^{+} \{S_i^{\text{CAL}}\} \right\}, \ i \in \mathcal{D}_{\text{calibration}}$</span></p><p>where <span>$\mathcal{D}_{\text{calibration}}$</span> denotes the designated calibration data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/inductive_classification.jl#L100-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLJModelInterface.predict-Tuple{ConformalPrediction.SimpleInductiveRegressor, Any, Any}" href="#MLJModelInterface.predict-Tuple{ConformalPrediction.SimpleInductiveRegressor, Any, Any}"><code>MLJModelInterface.predict</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MMI.predict(conf_model::SimpleInductiveRegressor, fitresult, Xnew)</code></pre><p>For the <a href="#ConformalPrediction.SimpleInductiveRegressor"><code>SimpleInductiveRegressor</code></a> prediction intervals are computed as follows,</p><p><span>$\hat{C}_{n,\alpha}(X_{n+1}) = \hat\mu(X_{n+1}) \pm \hat{q}_{n, \alpha}^{+} \{S_i^{\text{CAL}} \}, \ i \in \mathcal{D}_{\text{calibration}}$</span></p><p>where <span>$\mathcal{D}_{\text{calibration}}$</span> denotes the designated calibration data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/inductive_regression.jl#L52-L62">source</a></section></article><h2 id="Internal-functions"><a class="docs-heading-anchor" href="#Internal-functions">Internal functions</a><a id="Internal-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.AdaptiveInductiveClassifier" href="#ConformalPrediction.AdaptiveInductiveClassifier"><code>ConformalPrediction.AdaptiveInductiveClassifier</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>The <code>AdaptiveInductiveClassifier</code> is an improvement to the <a href="#ConformalPrediction.SimpleInductiveClassifier"><code>SimpleInductiveClassifier</code></a> and the <a href="#ConformalPrediction.NaiveClassifier"><code>NaiveClassifier</code></a>. Contrary to the <a href="#ConformalPrediction.NaiveClassifier"><code>NaiveClassifier</code></a> it computes nonconformity scores using a designated calibration dataset like the <a href="#ConformalPrediction.SimpleInductiveClassifier"><code>SimpleInductiveClassifier</code></a>. Contrary to the <a href="#ConformalPrediction.SimpleInductiveClassifier"><code>SimpleInductiveClassifier</code></a> it utilizes the softmax output of all classes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/inductive_classification.jl#L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.CVMinMaxRegressor" href="#ConformalPrediction.CVMinMaxRegressor"><code>ConformalPrediction.CVMinMaxRegressor</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Constructor for <code>CVMinMaxRegressor</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/transductive_regression.jl#L443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.CVPlusRegressor" href="#ConformalPrediction.CVPlusRegressor"><code>ConformalPrediction.CVPlusRegressor</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Constructor for <code>CVPlusRegressor</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/transductive_regression.jl#L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.ConformalInterval" href="#ConformalPrediction.ConformalInterval"><code>ConformalPrediction.ConformalInterval</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>An abstract base type for conformal models that produce interval-valued predictions. This includes most conformal regression models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/conformal_models.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.ConformalProbabilistic" href="#ConformalPrediction.ConformalProbabilistic"><code>ConformalPrediction.ConformalProbabilistic</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>An abstract base type for conformal models that produce probabilistic predictions. This includes some conformal classifier like Venn-ABERS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/conformal_models.jl#L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.ConformalProbabilisticSet" href="#ConformalPrediction.ConformalProbabilisticSet"><code>ConformalPrediction.ConformalProbabilisticSet</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>An abstract base type for conformal models that produce set-valued probabilistic predictions. This includes most conformal classification models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/conformal_models.jl#L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.JackknifeMinMaxRegressor" href="#ConformalPrediction.JackknifeMinMaxRegressor"><code>ConformalPrediction.JackknifeMinMaxRegressor</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Constructor for <code>JackknifeMinMaxRegressor</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/transductive_regression.jl#L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.JackknifePlusAbMinMaxRegressor" href="#ConformalPrediction.JackknifePlusAbMinMaxRegressor"><code>ConformalPrediction.JackknifePlusAbMinMaxRegressor</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Constructor for <code>JackknifePlusAbPlusMinMaxRegressor</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/transductive_regression.jl#L674">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.JackknifePlusAbRegressor" href="#ConformalPrediction.JackknifePlusAbRegressor"><code>ConformalPrediction.JackknifePlusAbRegressor</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Constructor for <code>JackknifePlusAbPlusRegressor</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/transductive_regression.jl#L568">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.JackknifePlusRegressor" href="#ConformalPrediction.JackknifePlusRegressor"><code>ConformalPrediction.JackknifePlusRegressor</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Constructor for <code>JackknifePlusRegressor</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/transductive_regression.jl#L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.JackknifeRegressor" href="#ConformalPrediction.JackknifeRegressor"><code>ConformalPrediction.JackknifeRegressor</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Constructor for <code>JackknifeRegressor</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/transductive_regression.jl#L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.NaiveClassifier" href="#ConformalPrediction.NaiveClassifier"><code>ConformalPrediction.NaiveClassifier</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>The <code>NaiveClassifier</code> is the simplest approach to Inductive Conformal Classification. Contrary to the <a href="#ConformalPrediction.NaiveClassifier"><code>NaiveClassifier</code></a> it computes nonconformity scores using a designated training dataset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/transductive_classification.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.NaiveRegressor" href="#ConformalPrediction.NaiveRegressor"><code>ConformalPrediction.NaiveRegressor</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>The <code>NaiveRegressor</code> for conformal prediction is the simplest approach to conformal regression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/transductive_regression.jl#L5-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.SimpleInductiveClassifier" href="#ConformalPrediction.SimpleInductiveClassifier"><code>ConformalPrediction.SimpleInductiveClassifier</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>The <code>SimpleInductiveClassifier</code> is the simplest approach to Inductive Conformal Classification. Contrary to the <a href="#ConformalPrediction.NaiveClassifier"><code>NaiveClassifier</code></a> it computes nonconformity scores using a designated calibration dataset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/inductive_classification.jl#L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.SimpleInductiveRegressor" href="#ConformalPrediction.SimpleInductiveRegressor"><code>ConformalPrediction.SimpleInductiveRegressor</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>The <code>SimpleInductiveRegressor</code> is the simplest approach to Inductive Conformal Regression. Contrary to the <a href="#ConformalPrediction.NaiveRegressor"><code>NaiveRegressor</code></a> it computes nonconformity scores using a designated calibration dataset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/inductive_regression.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction._aggregate-Tuple{Any, Union{String, Symbol}}" href="#ConformalPrediction._aggregate-Tuple{Any, Union{String, Symbol}}"><code>ConformalPrediction._aggregate</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_aggregate(y, aggregate::Union{Symbol,String})</code></pre><p>Helper function that performs aggregation across vector of predictions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/transductive_regression.jl#L543-L547">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.classification_loss-Tuple{ConformalPrediction.ConformalProbabilisticSet, Any, Any, Any}" href="#ConformalPrediction.classification_loss-Tuple{ConformalPrediction.ConformalProbabilisticSet, Any, Any, Any}"><code>ConformalPrediction.classification_loss</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">classification_loss(
    conf_model::ConformalProbabilisticSet, fitresult, X, y;
    loss_matrix::Union{AbstractMatrix,UniformScaling}=UniformScaling(1.0),
    temp::Real=0.5
)</code></pre><p>Computes the calibration loss following Stutz et al. (2022): https://openreview.net/pdf?id=t8O-4LKFVx. Following the notation in the paper, the loss is computed as,</p><p class="math-container">\[\mathcal{L}(C_{\theta}(x;\tau),y) = \sum_k L_{y,k} \left[ (1 - C_{\theta,k}(x;\tau)) \mathbf{I}_{y=k} + C_{\theta,k}(x;\tau) \mathbf{I}_{y\ne k} \right]\]</p><p>where <span>$\tau$</span> is just the quantile <code>qÃÇ</code> and <span>$\kappa$</span> is the target set size (defaults to <span>$1$</span>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/training/losses.jl#L84-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.generate_lims-NTuple{5, Any}" href="#ConformalPrediction.generate_lims-NTuple{5, Any}"><code>ConformalPrediction.generate_lims</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate_lims(x1, x2, xlims, ylims)</code></pre><p>Small helper function then generates the <code>xlims</code> and <code>ylims</code> for the plot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/plotting.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.get_names-Tuple{Any}" href="#ConformalPrediction.get_names-Tuple{Any}"><code>ConformalPrediction.get_names</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_names(X)</code></pre><p>Helper function to get variables names of <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/plotting.jl#L25-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.is_classification-Tuple{Any}" href="#ConformalPrediction.is_classification-Tuple{Any}"><code>ConformalPrediction.is_classification</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_classification(yÃÇ)</code></pre><p>Helper function that checks if conformal prediction <code>yÃÇ</code> comes from a conformal classification model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/utils.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.is_covered-Tuple{Any, Any}" href="#ConformalPrediction.is_covered-Tuple{Any, Any}"><code>ConformalPrediction.is_covered</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_covered(yÃÇ, y)</code></pre><p>Helper function to check if <code>y</code> is contained in conformal region. Based on whether conformal predictions <code>yÃÇ</code> are set- or interval-valued, different checks are executed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/evaluation/utils.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.is_covered_interval-Tuple{Any, Any}" href="#ConformalPrediction.is_covered_interval-Tuple{Any, Any}"><code>ConformalPrediction.is_covered_interval</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_covered_interval(yÃÇ, y)</code></pre><p>Helper function to check if <code>y</code> is contained in conformal interval.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/evaluation/utils.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.is_covered_set-Tuple{Any, Any}" href="#ConformalPrediction.is_covered_set-Tuple{Any, Any}"><code>ConformalPrediction.is_covered_set</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_covered_set(yÃÇ, y)</code></pre><p>Helper function to check if <code>y</code> is contained in conformal set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/evaluation/utils.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.is_regression-Tuple{Any}" href="#ConformalPrediction.is_regression-Tuple{Any}"><code>ConformalPrediction.is_regression</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_regression(yÃÇ)</code></pre><p>Helper function that checks if conformal prediction <code>yÃÇ</code> comes from a conformal regression model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/utils.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.reformat_interval-Tuple{Any}" href="#ConformalPrediction.reformat_interval-Tuple{Any}"><code>ConformalPrediction.reformat_interval</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reformat_interval(yÃÇ)</code></pre><p>Reformats conformal interval predictions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/utils.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.reformat_mlj_prediction-Tuple{Any}" href="#ConformalPrediction.reformat_mlj_prediction-Tuple{Any}"><code>ConformalPrediction.reformat_mlj_prediction</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reformat_mlj_prediction(yÃÇ)</code></pre><p>A helper function that extracts only the output (predicted values) for whatever is returned from <code>MMI.predict(model, fitresult, Xnew)</code>. This is currently used to avoid issues when calling <code>MMI.predict(model, fitresult, Xnew)</code> in pipelines.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/utils.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.score" href="#ConformalPrediction.score"><code>ConformalPrediction.score</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">score(conf_model::AdaptiveInductiveClassifier, ::Type{&lt;:Supervised}, fitresult, X, y::Union{Nothing,AbstractArray}=nothing)</code></pre><p>Score method for the <a href="#ConformalPrediction.AdaptiveInductiveClassifier"><code>AdaptiveInductiveClassifier</code></a> dispatched for any <code>&lt;:Supervised</code> model.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/inductive_classification.jl#L174-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.score" href="#ConformalPrediction.score"><code>ConformalPrediction.score</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">score(conf_model::AdaptiveInductiveClassifier, ::Type{&lt;:MLJFluxModel}, fitresult, X, y::Union{Nothing,AbstractArray}=nothing)</code></pre><p>Overloads the <code>score</code> function for the <code>MLJFluxModel</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/training/inductive_classification.jl#L58-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.score" href="#ConformalPrediction.score"><code>ConformalPrediction.score</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">score(conf_model::AdaptiveInductiveClassifier, ::Type{&lt;:EitherEnsembleModel{&lt;:MLJFluxModel}}, fitresult, X, y::Union{Nothing,AbstractArray}=nothing)</code></pre><p>Overloads the <code>score</code> function for ensembles of <code>MLJFluxModel</code> types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/training/inductive_classification.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.score" href="#ConformalPrediction.score"><code>ConformalPrediction.score</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">score(conf_model::ConformalProbabilisticSet, fitresult, X, y::Union{Nothing,AbstractArray}=nothing)</code></pre><p>Generic score method for the <a href="#ConformalPrediction.ConformalProbabilisticSet"><code>ConformalProbabilisticSet</code></a>. It computes nonconformity scores using the heuristic function <code>h</code> and the softmax probabilities of the true class. Method is dispatched for different Conformal Probabilistic Sets and atomic models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/inductive_classification.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.score" href="#ConformalPrediction.score"><code>ConformalPrediction.score</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">score(conf_model::SimpleInductiveClassifier, ::Type{&lt;:EitherEnsembleModel{&lt;:MLJFluxModel}}, fitresult, X, y::Union{Nothing,AbstractArray}=nothing)</code></pre><p>Overloads the <code>score</code> function for ensembles of <code>MLJFluxModel</code> types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/training/inductive_classification.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.score" href="#ConformalPrediction.score"><code>ConformalPrediction.score</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">score(conf_model::InductiveModel, model::MLJFluxModel, fitresult, X, y::Union{Nothing,AbstractArray}=nothing)</code></pre><p>Overloads the <code>score</code> function for the <code>MLJFluxModel</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/training/inductive_classification.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.score" href="#ConformalPrediction.score"><code>ConformalPrediction.score</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">score(conf_model::SimpleInductiveClassifier, ::Type{&lt;:Supervised}, fitresult, X, y::Union{Nothing,AbstractArray}=nothing)</code></pre><p>Score method for the <a href="#ConformalPrediction.SimpleInductiveClassifier"><code>SimpleInductiveClassifier</code></a> dispatched for any <code>&lt;:Supervised</code> model.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/inductive_classification.jl#L50-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.smooth_size_loss-Tuple{ConformalPrediction.ConformalProbabilisticSet, Any, Any}" href="#ConformalPrediction.smooth_size_loss-Tuple{ConformalPrediction.ConformalProbabilisticSet, Any, Any}"><code>ConformalPrediction.smooth_size_loss</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function smooth_size_loss(
    conf_model::ConformalProbabilisticSet, fitresult, X;
    temp::Real=0.5, Œ∫::Real=1.0
)</code></pre><p>Computes the smooth (differentiable) size loss following Stutz et al. (2022): https://openreview.net/pdf?id=t8O-4LKFVx. First, soft assignment probabilities are computed for new data <code>X</code>. Then (following the notation in the paper) the loss is computed as, </p><p class="math-container">\[\Omega(C_{\theta}(x;\tau)) = \max (0, \sum_k C_{\theta,k}(x;\tau) - \kappa)\]</p><p>where <span>$\tau$</span> is just the quantile <code>qÃÇ</code> and <span>$\kappa$</span> is the target set size (defaults to <span>$1$</span>). For empty sets, the loss is computed as <span>$K - \kappa$</span>, that is the maximum set size minus the target set size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/training/losses.jl#L35-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ConformalPrediction.split_data-Tuple{ConformalPrediction.ConformalProbabilisticSet, Any, Any}" href="#ConformalPrediction.split_data-Tuple{ConformalPrediction.ConformalProbabilisticSet, Any, Any}"><code>ConformalPrediction.split_data</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">split_data(conf_model::ConformalProbabilisticSet, indices::Base.OneTo{Int})</code></pre><p>Splits the data into a proper training and calibration set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/inductive_classification.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plots.areaplot-Tuple{ConformalPrediction.ConformalProbabilisticSet, Any, Any, Any}" href="#Plots.areaplot-Tuple{ConformalPrediction.ConformalProbabilisticSet, Any, Any, Any}"><code>Plots.areaplot</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Plots.areaplot(
    conf_model::ConformalProbabilisticSet, fitresult, X, y;
    input_var::Union{Nothing,Int,Symbol}=nothing,
    kwargs...
)</code></pre><p>A <code>Plots.jl</code> recipe/method extension that can be used to visualize the conformal predictions of any fitted conformal classifier. Using a stacked area chart, this function plots the softmax output(s) contained the the conformal predictions set on the vertical axis against an input variable <code>X</code> on the horizontal axis. In the case of multiple input variables, the <code>input_var</code> argument can be used to specify the desired input variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/plotting.jl#L182-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plots.bar-Tuple{ConformalModel, Any, Any}" href="#Plots.bar-Tuple{ConformalModel, Any, Any}"><code>Plots.bar</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Plots.bar(conf_model::ConformalModel, fitresult, X; label=&quot;&quot;, xtickfontsize=6, kwrgs...)</code></pre><p>A <code>Plots.jl</code> recipe/method extension that can be used to visualize the set size distribution of a conformal predictor. In the regression case, prediction interval widths are stratified into discrete bins. It can be useful to plot the distribution of set sizes in order to visually asses how adaptive a conformal predictor is. For more adaptive predictors the distribution of set sizes is typically spread out more widely, which reflects that ‚Äúthe procedure is effectively distinguishing between easy and hard inputs‚Äù. This is desirable: when for a given sample it is difficult to make predictions, this should be reflected in the set size (or interval width in the regression case). Since ‚Äòdifficult‚Äô lies on some spectrum that ranges from ‚Äòvery easy‚Äô to ‚Äòvery difficult‚Äô the set size should very across the spectrum of ‚Äòempty set‚Äô to ‚Äòall labels included‚Äô.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/plotting.jl#L311-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Plots.contourf-Tuple{ConformalPrediction.ConformalProbabilisticSet, Any, Any, Any}" href="#Plots.contourf-Tuple{ConformalPrediction.ConformalProbabilisticSet, Any, Any, Any}"><code>Plots.contourf</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Plots.contourf(conf_model::ConformalModel,fitresult,X,y;kwargs...)</code></pre><p>A <code>Plots.jl</code> recipe/method extension that can be used to visualize the conformal predictions of a fitted conformal classifier with exactly two input variable. Data (<code>X</code>,<code>y</code>) are plotted as dots and overlaid with predictions sets. <code>y</code> is used to indicate the ground-truth labels of samples by colour. Samples are visualized in a two-dimensional feature space, so it is expected that <code>X</code> <span>$\in \mathcal{R}^2$</span>. By default, a contour is used to visualize the softmax output of the conformal classifier for the target label, where <code>target</code> indicates can be used to define the index of the target label. Transparent regions indicate that the prediction set does not include the <code>target</code> label. </p><p><strong>Target</strong></p><p>In the binary case, <code>target</code> defaults to <code>2</code>, indexing the second label: assuming the labels are <code>[0,1]</code> then the softmax output for <code>1</code> is shown. In the multi-class cases, <code>target</code> defaults to the first class: for example, if the labels are <code>[&quot;üê∂&quot;, &quot;üê±&quot;, &quot;üê≠&quot;]</code> (in that order) then the contour indicates the softmax output for <code>&quot;üê∂&quot;</code>.</p><p><strong>Set Size</strong></p><p>If <code>plot_set_size</code> is set to <code>true</code>, then the contour instead visualises the the set size.</p><p><strong>Univariate and Higher Dimensional Inputs</strong></p><p>For univariate of multiple inputs (&gt;2), this function is not applicable. See <a href="#Plots.areaplot-Tuple{ConformalPrediction.ConformalProbabilisticSet, Any, Any, Any}"><code>Plots.areaplot(conf_model::ConformalProbabilisticSet, fitresult, X, y; kwargs...)</code></a> for an alternative way to visualize prediction for any conformal classifier.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/plotting.jl#L39-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.plot-Tuple{ConformalPrediction.ConformalInterval, Any, Any, Any}" href="#RecipesBase.plot-Tuple{ConformalPrediction.ConformalInterval, Any, Any, Any}"><code>RecipesBase.plot</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Plots.plot(
    conf_model::ConformalInterval, fitresult, X, y;
    kwrgs...
)</code></pre><p>A <code>Plots.jl</code> recipe/method extension that can be used to visualize the conformal predictions of a fitted conformal regressor. Data (<code>X</code>,<code>y</code>) are plotted as dots and overlaid with predictions intervals. <code>y</code> is plotted on the vertical axis against a single variable <code>X</code> on the horizontal axis. A shaded area indicates the prediction interval. The line in the center of the interval is the midpoint of the interval and can be interpreted as the point estimate of the conformal regressor. In case <code>X</code> is multi-dimensional, <code>input_var</code> can be used to specify the input variable of interest that will be used for the horizontal axis. If unspecified, the first variable will be plotting by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/10634007d4585eb4ed7acf30ffafc4624318bb25/src/conformal_models/plotting.jl#L234-L241">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../explanation/architecture/">¬´ Package Architecture</a><a class="docs-footer-nextpage" href="../contribute/">üõ† Contribute ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 7 July 2023 09:29">Friday 7 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
