<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Regression ¬∑ ConformalPrediction.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://juliatrustworthyai.github.io/ConformalPrediction.jl/tutorials/regression/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="ConformalPrediction.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ConformalPrediction.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">üè† Home</a></li><li><span class="tocitem">ü´£ Tutorials</span><ul><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../classification/">Classification</a></li><li class="is-active"><a class="tocitem" href>Regression</a><ul class="internal"><li><a class="tocitem" href="#Data"><span>Data</span></a></li><li><a class="tocitem" href="#Model"><span>Model</span></a></li><li><a class="tocitem" href="#Conformal-Prediction"><span>Conformal Prediction</span></a></li><li><a class="tocitem" href="#Evaluation"><span>Evaluation</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../plotting/">Visualizations</a></li></ul></li><li><span class="tocitem">ü´° How-To Guides</span><ul><li><a class="tocitem" href="../../how_to_guides/">Overview</a></li><li><a class="tocitem" href="../../how_to_guides/mnist/">How to Conformalize a Deep Image Classifier</a></li><li><a class="tocitem" href="../../how_to_guides/llm/">How to Conformalize a Large Language Model</a></li><li><a class="tocitem" href="../../how_to_guides/timeseries/">How to Conformalize a Time Series Model</a></li></ul></li><li><span class="tocitem">ü§ì Explanation</span><ul><li><a class="tocitem" href="../../explanation/">Overview</a></li><li><a class="tocitem" href="../../explanation/architecture/">Package Architecture</a></li></ul></li><li><a class="tocitem" href="../../_reference/">üßê Reference</a></li><li><a class="tocitem" href="../../contribute/">üõ† Contribute</a></li><li><a class="tocitem" href="../../faq/">‚ùì FAQ</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">ü´£ Tutorials</a></li><li class="is-active"><a href>Regression</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Regression</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/juliatrustworthyai/ConformalPrediction.jl/blob/main/docs/src/tutorials/regression.md#" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Regression"><a class="docs-heading-anchor" href="#Regression">Regression</a><a id="Regression-1"></a><a class="docs-heading-anchor-permalink" href="#Regression" title="Permalink"></a></h1><p>This tutorial presents and compares different approaches to Conformal Regression using a simple synthetic dataset. It is inspired by this MAPIE <a href="https://mapie.readthedocs.io/en/latest/examples_regression/4-tutorials/plot_main-tutorial-regression.html#">tutorial</a>.</p><h2 id="Data"><a class="docs-heading-anchor" href="#Data">Data</a><a id="Data-1"></a><a class="docs-heading-anchor-permalink" href="#Data" title="Permalink"></a></h2><p>We begin by generating some synthetic regression data below:</p><pre><code class="language-julia hljs"># Regression data:

# Inputs:
N = 600
xmax = 5.0
using Distributions
d = Uniform(-xmax, xmax)
X = rand(d, N)
X = reshape(X, :, 1)

# Outputs:
noise = 0.5
fun(X) = X * sin(X)
Œµ = randn(N) .* noise
y = @.(fun(X)) + Œµ
y = vec(y)

# Partition:
using MLJ
train, test = partition(eachindex(y), 0.4, 0.4, shuffle=true)

using Plots
scatter(X, y, label=&quot;Observed&quot;)
xrange = range(-xmax,xmax,length=N)
plot!(xrange, @.(fun(xrange)), lw=4, label=&quot;Ground truth&quot;, ls=:dash, colour=:black)</code></pre><h2 id="Model"><a class="docs-heading-anchor" href="#Model">Model</a><a id="Model-1"></a><a class="docs-heading-anchor-permalink" href="#Model" title="Permalink"></a></h2><p>To model this data we will use polynomial regression. There is currently no out-of-the-box support for polynomial feature transformations in <code>MLJ</code>, but it is easy enough to add a little helper function for this. Note how we define a linear pipeline <code>pipe</code> here. Since pipelines in <code>MLJ</code> are just models, we can use the generated object as an input to <code>conformal_model</code> below.</p><pre><code class="language-julia hljs">LinearRegressor = @load LinearRegressor pkg=MLJLinearModels
degree_polynomial = 10
polynomial_features(X, degree::Int) = reduce(hcat, map(i -&gt; X.^i, 1:degree))
pipe = (X -&gt; MLJ.table(polynomial_features(MLJ.matrix(X), degree_polynomial))) |&gt; LinearRegressor()</code></pre><h2 id="Conformal-Prediction"><a class="docs-heading-anchor" href="#Conformal-Prediction">Conformal Prediction</a><a id="Conformal-Prediction-1"></a><a class="docs-heading-anchor-permalink" href="#Conformal-Prediction" title="Permalink"></a></h2><p>Next, we conformalize our polynomial regressor using every available approach (except the Naive approach):</p><pre><code class="language-julia hljs">using ConformalPrediction
conformal_models = merge(values(available_models[:regression])...)
results = Dict()
for _mod in keys(conformal_models) 
    conf_model = conformal_model(pipe; method=_mod, coverage=0.95)
    global mach = machine(conf_model, X, y)
    MLJ.fit!(mach, rows=train)
    results[_mod] = mach
end</code></pre><p>Finally, let us look at the resulting conformal predictions in each case. The chart below shows the results: for the first 4 methods it displays the training data (dots) overlaid with the conformal prediction interval (shaded area). At first glance it is hard to spot any major differences between the different approaches. Next, we will look at how we can evaluate and benchmark these predictions.</p><pre><code class="language-julia hljs">using Plots
zoom = -0.5
xrange = range(-xmax+zoom,xmax-zoom,length=N)
plt_list = []

for (_mod, mach) in first(results, n_charts)
    plt = plot(mach.model, mach.fitresult, X, y, zoom=zoom, title=_mod)
    plot!(plt, xrange, @.(fun(xrange)), lw=1, ls=:dash, colour=:black, label=&quot;Ground truth&quot;)
    push!(plt_list, plt)
end

plot(plt_list..., size=(800,500))</code></pre><p><img src="../regression_files/figure-commonmark/fig-cp-output-1.svg" alt="Figure¬†1: Conformal prediction regions."/></p><h2 id="Evaluation"><a class="docs-heading-anchor" href="#Evaluation">Evaluation</a><a id="Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation" title="Permalink"></a></h2><p>For evaluation of conformal predictors we follow Angelopoulos and Bates (2021) (Section 3). As a first step towards adaptiveness (adaptivity), the authors recommend to inspect the set size of conformal predictions. The chart below shows the interval width for the different methods along with the ground truth interval width:</p><pre><code class="language-julia hljs">xrange = range(-xmax,xmax,length=N)
plt = plot(xrange, ones(N) .* (1.96*2*noise), ls=:dash, colour=:black, label=&quot;Ground truth&quot;, lw=2)
for (_mod, mach) in results
    yÃÇ = predict(mach, reshape([x for x in xrange], :, 1))
    y_size = set_size.(yÃÇ)
    plot!(xrange, y_size, label=String(_mod))
end
plt</code></pre><p><img src="../regression_files/figure-commonmark/fig-setsize-output-1.svg" alt="Figure¬†2: Prediction interval width."/></p><p>We can also use specific metrics like <strong>empirical coverage</strong> and <strong>size-stratified coverage</strong> to check for correctness and adaptiveness, respectively (<strong>angelopoulus2021gentle?</strong>). To this end, the package provides custom measures that are compatible with <code>MLJ.jl</code>. In other words, we can evaluate model performance in true <code>MLJ.jl</code> fashion (see <a href="https://alan-turing-institute.github.io/MLJ.jl/dev/evaluating_model_performance/">here</a>).</p><p>The code below runs the evaluation with respect to both metrics, <code>emp_coverage</code> and <code>ssc</code> for a single conformal machine:</p><pre><code class="language-julia hljs">_mod, mach = first(results)
_eval = evaluate!(
    mach,
    operation=predict,
    measure=[emp_coverage, ssc]
)
display(_eval)
println(&quot;Empirical coverage for $(_mod): $(round(_eval.measurement[1], digits=3))&quot;)
println(&quot;SSC for $(_mod): $(round(_eval.measurement[2], digits=3))&quot;)</code></pre><pre><code class="nohighlight hljs">PerformanceEvaluation object with these fields:
  measure, operation, measurement, per_fold,
  per_observation, fitted_params_per_fold,
  report_per_fold, train_test_rows
Extract:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ measure                                      ‚îÇ operation ‚îÇ measurement ‚îÇ 1.9 ‚ãØ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ ConformalPrediction.emp_coverage             ‚îÇ predict   ‚îÇ 0.94        ‚îÇ 0.0 ‚ãØ
‚îÇ ConformalPrediction.size_stratified_coverage ‚îÇ predict   ‚îÇ 0.94        ‚îÇ 0.0 ‚ãØ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                                                               2 columns omitted

Empirical coverage for jackknife_plus_ab: 0.94
SSC for jackknife_plus_ab: 0.94</code></pre><p>Note that, in the regression case, stratified set sizes correspond to discretized interval widths.</p><p>To benchmark the different approaches, we evaluate them iteratively below. As expected, more conservative approaches like Jackknife-min‚ÄÜmax‚ÄÜ and CV-min‚ÄÜmax‚ÄÜ attain higher aggregate and conditional coverage. Note that size-stratified is not available for methods that produce constant intervals, like standard Jackknife.</p><pre><code class="language-julia hljs">using DataFrames
bmk = DataFrame()
for (_mod, mach) in results
    _eval = evaluate!(
        mach,
        resampling=CV(;nfolds=5),
        operation=predict,
        measure=[emp_coverage, ssc]
    )
    _bmk = DataFrame(
        Dict(
            :model =&gt; _mod,
            :emp_coverage =&gt; _eval.measurement[1],
            :ssc =&gt; _eval.measurement[2]
        )
    )
    bmk = vcat(bmk, _bmk)
end

show(sort(select!(bmk, [2,1,3]), 2, rev=true))</code></pre><pre><code class="nohighlight hljs">9√ó3 DataFrame
 Row ‚îÇ model                     emp_coverage  ssc      
     ‚îÇ Symbol                    Float64       Float64  
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   1 ‚îÇ jackknife_plus_ab_minmax      0.988333  0.980547
   2 ‚îÇ cv_minmax                     0.96      0.910873
   3 ‚îÇ simple_inductive              0.953333  0.953333
   4 ‚îÇ jackknife_minmax              0.946667  0.869103
   5 ‚îÇ cv_plus                       0.945     0.866549
   6 ‚îÇ jackknife_plus_ab             0.941667  0.941667
   7 ‚îÇ jackknife_plus                0.941667  0.871606
   8 ‚îÇ jackknife                     0.941667  0.941667
   9 ‚îÇ naive                         0.938333  0.938333</code></pre><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><p>Angelopoulos, Anastasios N., and Stephen Bates. 2021. ‚ÄúA Gentle Introduction to Conformal Prediction and Distribution-Free Uncertainty Quantification.‚Äù <a href="https://arxiv.org/abs/2107.07511">https://arxiv.org/abs/2107.07511</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../classification/">¬´ Classification</a><a class="docs-footer-nextpage" href="../plotting/">Visualizations ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 27 July 2023 00:45">Thursday 27 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
